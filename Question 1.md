# JavaNotes

## 1. Примитивы, классы и объекты
Язык Java определяет восемь элементарных типов данных: byte, short, int, long, char, float, 
double и boolean.
Элементарные типы называют также простыми, и в этой книге мы будем использовать оба эти термина. Элементарные типы можно разделить на четыре группы.
- Целые числа. Эта группа включает в себя типы byte, short, int и long, которые представляют точные целые числа со знаком.
- Числа с плавающей точкой. Эта группа включает в себя типы float и double , которые представляют числа, определенные с точностью до определенного десятичного знака.
- Символы. Эта группа включает в себя тип char, которая представляет символы символьного набора, такие как буквы и цифры.
- Булевы (логические) значения. Эта группа включает в себя тип boolean — специальный тип, предназначенный для представления значений типа “истинно/ложно”.

Элементарные типы представляют одиночные значения, а не сложные объекты. Хотя во всех других отношениях Java—полностью объектно-ориентированныйязык, элементарные типы данных таковыми не являются. Элементарные типы определены так, чтобы они обладали явным диапазоном допустимых значений и математически строгим поведением. В связи с требованием переносимости, предъявляемым к программам Java, все типы данных обладают строго определенным диапазоном допустимых значений. Например, независимо от конкретной платформы, значения типа int всегда являются 32-битовыми. Это позволяет создавать программы, которые гарантированно будут выполняться на любой машинной архитектуребез специального переноса. Хотя в некоторых средах строгое указание размера целых чисел может приводить к незначительному снижению производительности, оно абсолютно необходимо для обеспечения переносимости программ. Тип char был разработан для хранения символов Unicode, его можно так же использовать как целочисленный тип, пригодный для выполнения арифметических операций. Например, он позволяет выполнять сложение символов или уменьшать значение символьной переменной. 

Примитивный тип 	|Размер, бит 	|Минимум 	|Максимум 	|Тип упаковки
--- | --- | --- | --- | ---
boolean (логические значения) | — |	— |	— |	Boolean
char (символьные значения) |	16 |	Unicode 0 |	Unicode 2^16-1 |Character
byte (байт) |	8 	|-128 |	+127| 	Byte
short (короткое целое)| 	16 	|-2^15 	|+2^15-1 |	Short
int (целое) |	32 	|-2^31 |+2^31-1 |	Integer
long (длинное целое) |	64 	|-2^63 |	+2^63-1 |	Long
float (число с плавающей запятой) |	32 |	IEEE754 |	IEEE754 |	Float
double (число с повышенной точностью) |	64 |	IEEE754 |	IEEE754 |	Double
void (пустое значение) |	— |	— |	— |	Void 

Ширина целочисленного типа представляет не занимаемый объем памяти, а, скорее,поведение, определяемое им для переменных и выражений этого типа. Среда времени выполнения Java может использовать любой размер до тех пор, пока типы ведут себя объявленным образом. 

### Целочисленные литералы

Целочисленные значения — вероятно, наиболее часто используемый тип в типичной программе. Любое целочисленное значение является числовым литералом. Примерами могут служить значения 1, 2, 3 и 42. Все они — десятичные значения, описывающие числа с основанием 10. В числовых литералах могут использоваться еще два вида представления — восьмеричное (с основанием 8) ишестнадцатеричное (с основанием 16). В Java восьмеричные значения обозначаются ведущим нулем. Обычные десятичные числа не могут содержать ведущий нуль. Таким образом, внешне вполне допустимое значение 09 приведет к ошибке компиляции, поскольку 9 выходит за пределы диапазона от 0 до 7 допустимых восьмеричных значений. Чаще программисты используют шестнадцатеричное представление чисел, которое явно соответствует словам, размер которых равен 8, 16, 32 и 64 бит, составленным из8-битовыхблоков. Значения шестнадцатеричных констант обозначают ведущим нулем и символом х (Ох или ОХ). Диапазон допустимых шестнадцатеричных цифр — от 0 до 15, поэтому цифры от 10 до 15 заменяют буквами от А до F (или ота до f).
Целочисленные литералы создают значение типа int, которое вJava является 32-битовым целочисленным значением. Поскольку Java—строго типизированный язык, может возникать вопрос, каким образом можно присваивать целочисленный литерал одному из других целочисленных типов Java, такому как byte или long, не вызывая при этом ошибку несоответствия типа. К счастью, с подобными ситуациями легко справиться. Когда значение литерала присваивается переменной типаbyte или short, ошибка не происходит, если значение литерала находится в диапазоне допустимых значений этого типа. Кроме того, целочисленный литерал всегда можно присваивать переменной типа long. Однако чтобы указать литерал типа long, придется явно указать компилятору, что значение литерала имеет этот тип. Для этого к литералу дописывают строчную или прописную букву L. Например, 0x7ffffffffffffffL, 922337203 685477 5807L, - наибольший литерал типа long. Целочисленное значение можно присваивать типу char, если оно лежит в пределах допустимого диапазона этого типа.
Начиная с JDK 7 вы можете также определить целочисленные литералы, используя двоичную форму. Для этого перед значением используется префикс 0Ь или 0В. Например, Следующий код определяет десятичное значение 10 с использованием двоичного литерала.
```java
int х = 0b010;
```
Наличие двоичных литералов облегчает также ввод значений, используемых как битовые маски. В таком случае десятичное (или шестнадцатеричное) представление значения числа не отображает визуально способ его использования, а двоичный литерал отображает.
Начиная сJDK 7 вы можете также внедрить в целочисленный литерал один или несколько символов подчеркивания. Это облегчает чтение больших целочисленных литералов. При компиляции символы подчеркивания в литерале игнорируются. Например, в данном случае
```java
int х = 123_45б_789;
```
значением переменной х будет 123 456 789. Символы подчеркивания будут проигнорированы. Символы подчеркивания можно использовать только для разделения цифр. Они не могут располагаться в начале или в конце литерала, но вполне допустимо использование между двумя цифрами нескольких символов подчеркивания. Например, следующее вполне правильно.
```java
int х = 123___456___789;
```
Использование символов подчеркивания в целочисленном литерале особенно полезно при написании в коде таких элементов, как номера телефонов, идентификационные номера клиентов, номера частей и т.д. Они также полезны для визуальных группировок при определении двоичных литералов. Например, двоичные значения зачастую визуально группируются в блоки по четыре цифры, как показано далее.
```java
int х = 0b 101_0101_0001_1010;
```
#### Тип byte
Наименьший по размеру целочисленный тип. Это 8-битовый тип с диапазоном допустимых значений от -128 до 127. Переменные типа byte часто используются при работе с потоком данных из сети или файла, а также при работе с необработанными двоичными данными или в массивах для экономии памяти.
В арифметических выражениях с переменными типа short вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Строку с числом перевести в данный тип можно через метод parseByte(String):
```java
byte x = Byte.parseByte("100");
```
Класс Byte является оболочкой для данного типа. Без необходимости не используйте в Android класс Byte.
#### Тип short
Тип short - 16-битовый тип в диапазоне от -32768 до 32767. Используется очень редко.
В арифметических выражениях с переменными типа short вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Например, такой код не пройдёт:
```java
short fishNumber = 3;
short beefNumber = 2;
short breakfast = 0;
breakfast = fishNumber + beefNumber;
```
Java будет ругаться на последнюю строчку, так как итоговый результат не может быть short. Как вариант, вам нужно преобразовать результат снова в 16-битовое число.
```java
breakfast = (short) (fishNumber + beefNumber);
```
Это называется [приведением чисел](http://developer.alexanderklimov.ru/android/java/types.php#cast). Класс Short является оболочкой для данного типа. Явно перевести строку с числом в тип short можно через метод parseShort(String):
```java
short x = Short.parseShort("100");
```
#### Тип int
Целые числа, представленные типом int, являются самым распространённым типом в программе, с которым вы будете работать. Поэтому нужно хорошенько изучить его и узнать его достоинства и ограничения. Это 32-битовый тип, имеющий диапазон допустимых значений от -2147483648 до 2147483647 (около двух миллиардов). Этого числа вполне достаточно, чтобы посчитать всех котов на свете. Часто используется в циклах, индексировании массивов, хотя может показаться, что для небольших операций в цикле и массивах проще использовать short или byte. Нужно запомнить, что тип int эффективен в этих случаях из-за особенностей структуры вычислительных процессоров
#### Как сконвертировать строку или CharSequence в int?
```java
String mString = "42"; // строка
int mInt = Integer.parseInt(mString);
```
Если у вас тип CharSequence, то его можно сконвертировать сначала в строку при помощи метода toString(), а потом в int.
Метод parseInt() предпочтительнее метода valueOf():
```java
int number;
// плохой вариант
number2 = Integer.valueOf("1");
// отличный вариант
number = Integer.parseInt("1"); 
```
#### Как сконвертировать число в строку?
Если сложить число и строку, то Java автоматически конвертирует число в строку. Пользуясь этим свойством, программисты часто прибавляют к числу пустую строку. Но лучше использовать метод valueOf():
```java
int number = 1;
// плохой вариант
String numberString = "" + number;
// отличный вариант
String numberString = String.valueOf(number);
```
#### Тип long
Тип long - это 64-битный тип со знаком, используемый в тех случаях, когда используется очень большое значение, которое не способен хранить тип int. Можно использовать символы l или L для обозначения числа типа long. Рекомендовано использовать заглавную букву, чтобы избежать возможной путаницы. Класс Long является оболочкой для данного типа.. Конвертируем строку в данный тип:
```java
long x = Long.parseLong("100");
```
### Типы с плавающей точкой
Числа с плавающей точкой (иногда их называют действительными числами) применяются при вычислении выражений, в которых требуется точность до десятичного знака. Например, это может быть вычисление квадратного корня, значений синуса, косинуса и т.п. Существует два типа с плавающей точкой: float и double, которые представляют числа одинарной и двойной точности.
#### Тип float
Тип float определяет значение одинарной точности, которое занимает 32 бит. Переменные данного типа удобны, когда требуется дробная часть без особой точности, например, для денежных сумм. Рекомендуется добавлять символ F или f для обозначения этого типа, иначе число будет считаться типом double. float tugrik = 11.6F; Класс Float является оболочкой для данного типа.. Конвертируем из строки:
```java
float x = Float.parseFloat("19.95");
```
Также есть специальный класс BigDecimal для проведения арифметических действий повышенной точности (финансовые расчёты).
#### Тип double
Тип double обеспечивает двойную точность, что видно из его названия (double - двойная). Занимает 64 бит для хранения значений. Многие математические функции возвращают значения типа double. Кстати, современные процессоры оптимизированы под вычисления значений двойной точности, поэтому они предпочтительнее, чем тип float.
```java
double pi, r, a;
pi = 3.1416; // приблизительное значение числа π
r = 5.5; // радиус окружности
a = pi * r * r; // вычисляем площадь окружности
```
Тип double содержит не только числа, но и слова. Разделим число типа double на ноль. Ошибки не произойдёт.
```java
double positive_infinity = 12.0 / 0;
System.out.println(positive_infinity);
```
Пример вернёт значение Infinity (Бесконечность). Если разделить отрицательное число на ноль, то вернётся -Infinity. А что произойдёт, если сложить две бесконечности? Вернулось ещё одно слово - NaN.
```java
double positive_infinity = 12.0 / 0;
double negative_infinity = -15.0 / 0;
mInfoTextView.setText(String.valueOf(positive_infinity + negative_infinity));
```
Класс Double является оболочкой для данного типа. Конвертируем из строки.
```java
double x = Double.parseDouble("19.95");
```
#### Символы (тип char)
Для хранения символов Java использует специальный тип char. Он отличается от типа char в языках C/C++, где представляет собой целочисленный тип с размером 8 бит. В Java для char используется кодировка Unicode и для хранения Unicode-символов используется 16 бит или 2 байта. Диапазон допустимых значений - от 0 до 65536 (отрицательных значений не существует).
```java
char ch1, ch2, ch3;
ch1 = 67; // код переменной
ch2 = 'a'; // сам символ
ch3 = 116; // код переменной
mInfoTextView.setText("Слово из трёх букв: " + ch1 + ch2 + ch3);
```
Из примера выше видно, что переменной можно присвоить код символа или непосредственно сам символ, который следует окружить одинарными кавычками. Не следует путать символ 'a' со строкой "a", состоящей из одного символа. На экране монитора они выглядят одинаково, но в программах ведут себя по разному. Стандартные символы ASCII можно выводить сразу. Если нужно вывести специальный символ из Unicode, то можно воспользоваться шестнадцатеричным представлением кода в escape-последовательности - вы указываете обратную наклонную черту и четыре цифры после u. Например:
```java
char myChar = '\u0054';
```
Хотя тип char используется для хранения Unicode-символов, его можно использовать как целочисленный тип, используя сложение или вычитание.
```java
char ch1;
ch1 = 'x';
mInfoTextView.append("ch1 содержит " + ch1);
ch1++; // увеличим на единицу
mInfoTextView.append("ch1 содержит " + ch1);
```
В результате получим:
```java
ch1 содержит x
ch1 содержит y
```
Если вы думаете, что увеличив значение переменной ch1 ещё на одну единицу, получите символ "й", то глубоко заблуждаетесь. Чтобы узнать, какой символ содержится в значении переменной, заданной как int, можно воспользоваться двумя специальными методами из класса EncodingUtils.
Для стандартных символов ASCII:
```java
int i = 67;
byte[] data = { (byte) i };
CharSequence strSymbol = EncodingUtils.getAsciiString(data);
mInfoTextView.setText(strSymbol);
```
Для расширенной таблицы символов:
```java
int i = 379;
byte[] data = { (byte) i };
CharSequence strSymbol = EncodingUtils.getString(data, "windows-1251");
mInfoTextView.setText(strSymbol);
```
Методы работают со строками, но если мы используем строку из одного символа, то получим то, что нам нужно.
#### Класс Character
Класс Character является оболочкой вокруг типа char. Чтобы получить значение типа char, содержащее в объекте класса Character, вызовите метод charValue(). Класс содержит огромное количество констант и методов. Например, можно определить, является ли символ цифрой или буквой, или написан ли символ в нижнем или в верхнем регистре.
#### Булевы значения
Тип boolean предназначен для хранения логических значений и может принимать только одно из двух возможных значений: true или false. Данный тип всегда возвращается при использовании операторов сравнения (больше, меньше, равно, больше или равно, меньше или равно, не равно). Также он используется в управляющих операторах if и for.
```java
boolean check;
check = true;
```
В операторах if используется укороченная запись при значении true:
```java
if (check == true) ... // необязательный вариант
if (check) ... // укороченная запись
```
Java сам поймёт, что переменную check нужно сравнить с true.
#### Класс Boolean
Класс Boolean является оболочкой вокруг значений типа boolean. Чтобы получить значение типа boolean из объекта класса Boolean, используйте метод booleanValue(). Тип boolean использует 4 байт памяти, а Boolean - 16.
#### Приведение типов
Когда мы производим какие-то действия с переменными, то нужно следить за типами. Нельзя умножать котов на футбольные мячи, это противоречит здравому смыслу. Также и с переменными. Если вы присваиваете переменной одного типа значение другого типа, то вспоминайте теорию. Например, вы без проблем можете присвоить значение типа int переменной типа long, так как все числа из диапазона типа int гарантировано помещаются в диапазон чисел long. В этом случае Java выполнит преобразование автоматически, вы даже ничего не заметите.
Представим обратную картину - мы хотим присвоить переменной типа byte значение типа double. Java не сможет автоматически выполнить ваше желание. Не все числа типа double могут стать числом типа byte. Но часть чисел может, например, число 9. В таком случае используется так называемое приведение типов, чтобы подсказать Java о допустимости операции.
Итак, автоматическое преобразование типов осуществляется, если оба типа совместимы и длина целевого типа больше длины исходного типа. В этом случае происходит преобразование с расширением. Вы всегда можете преобразовать любое число типа byte в число типа int. Такая операция произойдёт без вашего участия автоматически. Таблица выглядит следующим образом.
![]()

## 2. Операторы, конструкции (циклы), выражения[\(2)](http://www.quizful.net/post/Java-RegExp), переменные и их область видимости, методы, модификаторы доступа
3. ООП: абстракция, полиморфизм, наследование, инкапсуляция в java. Оbject и его методы
4. Интерфейсы, абстрактные классы, вложенные и анонимные классы 
5. Перечисления (Enum-ы), исключения и дженерики
6. Коллекции
7. Классы String, Date, утилитарные методы Collections
8. Streams
9. Графический интерфейс 
10. Ревью лекция
