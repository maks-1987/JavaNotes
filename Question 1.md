# 1. Примитивы, классы и объекты
## Примитивы
Язык Java определяет восемь элементарных типов данных: byte, short, int, long, char, float, 
double и boolean.
Элементарные типы называют также простыми, и в этой книге мы будем использовать оба эти термина. Элементарные типы можно разделить на четыре группы.
- Целые числа. Эта группа включает в себя типы byte, short, int и long, которые представляют точные целые числа со знаком.
- Числа с плавающей точкой. Эта группа включает в себя типы float и double , которые представляют числа, определенные с точностью до определенного десятичного знака.
- Символы. Эта группа включает в себя тип char, которая представляет символы символьного набора, такие как буквы и цифры.
- Булевы (логические) значения. Эта группа включает в себя тип boolean — специальный тип, предназначенный для представления значений типа “истинно/ложно”.

Элементарные типы представляют одиночные значения, а не сложные объекты. Хотя во всех других отношениях Java—полностью объектно-ориентированныйязык, элементарные типы данных таковыми не являются. Элементарные типы определены так, чтобы они обладали явным диапазоном допустимых значений и математически строгим поведением. В связи с требованием переносимости, предъявляемым к программам Java, все типы данных обладают строго определенным диапазоном допустимых значений. Например, независимо от конкретной платформы, значения типа int всегда являются 32-битовыми. Это позволяет создавать программы, которые гарантированно будут выполняться на любой машинной архитектуребез специального переноса. Хотя в некоторых средах строгое указание размера целых чисел может приводить к незначительному снижению производительности, оно абсолютно необходимо для обеспечения переносимости программ. Тип char был разработан для хранения символов Unicode, его можно так же использовать как целочисленный тип, пригодный для выполнения арифметических операций. Например, он позволяет выполнять сложение символов или уменьшать значение символьной переменной. 

Примитивный тип 	|Размер, бит 	|Минимум 	|Максимум 	|Тип упаковки
--- | --- | --- | --- | ---
boolean (логические значения) | — |	— |	— |	Boolean
char (символьные значения) |	16 |	Unicode 0 |	Unicode 2^16-1 |Character
byte (байт) |	8 	|-128 |	+127| 	Byte
short (короткое целое)| 	16 	|-2^15 	|+2^15-1 |	Short
int (целое) |	32 	|-2^31 |+2^31-1 |	Integer
long (длинное целое) |	64 	|-2^63 |	+2^63-1 |	Long
float (число с плавающей запятой) |	32 |	IEEE754 |	IEEE754 |	Float
double (число с повышенной точностью) |	64 |	IEEE754 |	IEEE754 |	Double
void (пустое значение) |	— |	— |	— |	Void 

Ширина целочисленного типа представляет не занимаемый объем памяти, а, скорее,поведение, определяемое им для переменных и выражений этого типа. Среда времени выполнения Java может использовать любой размер до тех пор, пока типы ведут себя объявленным образом. 

## Целочисленные литералы

Целочисленные значения — вероятно, наиболее часто используемый тип в типичной программе. Любое целочисленное значение является числовым литералом. Примерами могут служить значения 1, 2, 3 и 42. Все они — десятичные значения, описывающие числа с основанием 10. В числовых литералах могут использоваться еще два вида представления — восьмеричное (с основанием 8) ишестнадцатеричное (с основанием 16). В Java восьмеричные значения обозначаются ведущим нулем. Обычные десятичные числа не могут содержать ведущий нуль. Таким образом, внешне вполне допустимое значение 09 приведет к ошибке компиляции, поскольку 9 выходит за пределы диапазона от 0 до 7 допустимых восьмеричных значений. Чаще программисты используют шестнадцатеричное представление чисел, которое явно соответствует словам, размер которых равен 8, 16, 32 и 64 бит, составленным из8-битовыхблоков. Значения шестнадцатеричных констант обозначают ведущим нулем и символом х (Ох или ОХ). Диапазон допустимых шестнадцатеричных цифр — от 0 до 15, поэтому цифры от 10 до 15 заменяют буквами от А до F (или ота до f).
Целочисленные литералы создают значение типа int, которое вJava является 32-битовым целочисленным значением. Поскольку Java—строго типизированный язык, может возникать вопрос, каким образом можно присваивать целочисленный литерал одному из других целочисленных типов Java, такому как byte или long, не вызывая при этом ошибку несоответствия типа. К счастью, с подобными ситуациями легко справиться. Когда значение литерала присваивается переменной типаbyte или short, ошибка не происходит, если значение литерала находится в диапазоне допустимых значений этого типа. Кроме того, целочисленный литерал всегда можно присваивать переменной типа long. Однако чтобы указать литерал типа long, придется явно указать компилятору, что значение литерала имеет этот тип. Для этого к литералу дописывают строчную или прописную букву L. Например, 0x7ffffffffffffffL, 922337203 685477 5807L, - наибольший литерал типа long. Целочисленное значение можно присваивать типу char, если оно лежит в пределах допустимого диапазона этого типа.
Начиная с JDK 7 вы можете также определить целочисленные литералы, используя двоичную форму. Для этого перед значением используется префикс 0Ь или 0В. Например, Следующий код определяет десятичное значение 10 с использованием двоичного литерала.
```java
int х = 0b010;
```
Наличие двоичных литералов облегчает также ввод значений, используемых как битовые маски. В таком случае десятичное (или шестнадцатеричное) представление значения числа не отображает визуально способ его использования, а двоичный литерал отображает.
Начиная сJDK 7 вы можете также внедрить в целочисленный литерал один или несколько символов подчеркивания. Это облегчает чтение больших целочисленных литералов. При компиляции символы подчеркивания в литерале игнорируются. Например, в данном случае
```java
int х = 123_45б_789;
```
значением переменной х будет 123 456 789. Символы подчеркивания будут проигнорированы. Символы подчеркивания можно использовать только для разделения цифр. Они не могут располагаться в начале или в конце литерала, но вполне допустимо использование между двумя цифрами нескольких символов подчеркивания. Например, следующее вполне правильно.
```java
int х = 123___456___789;
```
Использование символов подчеркивания в целочисленном литерале особенно полезно при написании в коде таких элементов, как номера телефонов, идентификационные номера клиентов, номера частей и т.д. Они также полезны для визуальных группировок при определении двоичных литералов. Например, двоичные значения зачастую визуально группируются в блоки по четыре цифры, как показано далее.
```java
int х = 0b 101_0101_0001_1010;
```
### Тип byte
Наименьший по размеру целочисленный тип. Это 8-битовый тип с диапазоном допустимых значений от -128 до 127. Переменные типа byte часто используются при работе с потоком данных из сети или файла, а также при работе с необработанными двоичными данными или в массивах для экономии памяти.
В арифметических выражениях с переменными типа short вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Строку с числом перевести в данный тип можно через метод parseByte(String):
```java
byte x = Byte.parseByte("100");
```
Класс Byte является оболочкой для данного типа. Без необходимости не используйте в Android класс Byte.
### Тип short
Тип short - 16-битовый тип в диапазоне от -32768 до 32767. Используется очень редко.
В арифметических выражениях с переменными типа short вычисления выполняются как с типом int, т.е. с помощью 32-битовой арифметики, а полученный результат будет 32-битовым. Например, такой код не пройдёт:
```java
short fishNumber = 3;
short beefNumber = 2;
short breakfast = 0;
breakfast = fishNumber + beefNumber;
```
Java будет ругаться на последнюю строчку, так как итоговый результат не может быть short. Как вариант, вам нужно преобразовать результат снова в 16-битовое число.
```java
breakfast = (short) (fishNumber + beefNumber);
```
Это называется приведением чисел. Класс Short является оболочкой для данного типа. Явно перевести строку с числом в тип short можно через метод parseShort(String):
```java
short x = Short.parseShort("100");
```
### Тип int
Целые числа, представленные типом int, являются самым распространённым типом в программе, с которым вы будете работать. Поэтому нужно хорошенько изучить его и узнать его достоинства и ограничения. Это 32-битовый тип, имеющий диапазон допустимых значений от -2147483648 до 2147483647 (около двух миллиардов). Этого числа вполне достаточно, чтобы посчитать всех котов на свете. Часто используется в циклах, индексировании массивов, хотя может показаться, что для небольших операций в цикле и массивах проще использовать short или byte. Нужно запомнить, что тип int эффективен в этих случаях из-за особенностей структуры вычислительных процессоров
### Как сконвертировать строку или CharSequence в int?
```java
String mString = "42"; // строка
int mInt = Integer.parseInt(mString);
```
Если у вас тип CharSequence, то его можно сконвертировать сначала в строку при помощи метода toString(), а потом в int.
Метод parseInt() предпочтительнее метода valueOf():
```java
int number;
// плохой вариант
number2 = Integer.valueOf("1");
// отличный вариант
number = Integer.parseInt("1"); 
```
### Как сконвертировать число в строку?
Если сложить число и строку, то Java автоматически конвертирует число в строку. Пользуясь этим свойством, программисты часто прибавляют к числу пустую строку. Но лучше использовать метод valueOf():
```java
int number = 1;
// плохой вариант
String numberString = "" + number;
// отличный вариант
String numberString = String.valueOf(number);
```
### Тип long
Тип long - это 64-битный тип со знаком, используемый в тех случаях, когда используется очень большое значение, которое не способен хранить тип int. Можно использовать символы l или L для обозначения числа типа long. Рекомендовано использовать заглавную букву, чтобы избежать возможной путаницы. Класс Long является оболочкой для данного типа.. Конвертируем строку в данный тип:
```java
long x = Long.parseLong("100");
```
## Типы с плавающей точкой
Числа с плавающей точкой (иногда их называют действительными числами) применяются при вычислении выражений, в которых требуется точность до десятичного знака. Например, это может быть вычисление квадратного корня, значений синуса, косинуса и т.п. Существует два типа с плавающей точкой: float и double, которые представляют числа одинарной и двойной точности.
### Тип float
Тип float определяет значение одинарной точности, которое занимает 32 бит. Переменные данного типа удобны, когда требуется дробная часть без особой точности, например, для денежных сумм. Рекомендуется добавлять символ F или f для обозначения этого типа, иначе число будет считаться типом double. float tugrik = 11.6F; Класс Float является оболочкой для данного типа.. Конвертируем из строки:
```java
float x = Float.parseFloat("19.95");
```
Также есть специальный класс BigDecimal для проведения арифметических действий повышенной точности (финансовые расчёты).
### Тип double
Тип double обеспечивает двойную точность, что видно из его названия (double - двойная). Занимает 64 бит для хранения значений. Многие математические функции возвращают значения типа double. Кстати, современные процессоры оптимизированы под вычисления значений двойной точности, поэтому они предпочтительнее, чем тип float.
```java
double pi, r, a;
pi = 3.1416; // приблизительное значение числа π
r = 5.5; // радиус окружности
a = pi * r * r; // вычисляем площадь окружности
```
Тип double содержит не только числа, но и слова. Разделим число типа double на ноль. Ошибки не произойдёт.
```java
double positive_infinity = 12.0 / 0;
System.out.println(positive_infinity);
```
Пример вернёт значение Infinity (Бесконечность). Если разделить отрицательное число на ноль, то вернётся -Infinity. А что произойдёт, если сложить две бесконечности? Вернулось ещё одно слово - NaN.
```java
double positive_infinity = 12.0 / 0;
double negative_infinity = -15.0 / 0;
mInfoTextView.setText(String.valueOf(positive_infinity + negative_infinity));
```
Класс Double является оболочкой для данного типа. Конвертируем из строки.
```java
double x = Double.parseDouble("19.95");
```
## Символы (тип char)
Для хранения символов Java использует специальный тип char. Он отличается от типа char в языках C/C++, где представляет собой целочисленный тип с размером 8 бит. В Java для char используется кодировка Unicode и для хранения Unicode-символов используется 16 бит или 2 байта. Диапазон допустимых значений - от 0 до 65536 (отрицательных значений не существует).
```java
char ch1, ch2, ch3;
ch1 = 67; // код переменной
ch2 = 'a'; // сам символ
ch3 = 116; // код переменной
mInfoTextView.setText("Слово из трёх букв: " + ch1 + ch2 + ch3);
```
Из примера выше видно, что переменной можно присвоить код символа или непосредственно сам символ, который следует окружить одинарными кавычками. Не следует путать символ 'a' со строкой "a", состоящей из одного символа. На экране монитора они выглядят одинаково, но в программах ведут себя по разному. Стандартные символы ASCII можно выводить сразу. Если нужно вывести специальный символ из Unicode, то можно воспользоваться шестнадцатеричным представлением кода в escape-последовательности - вы указываете обратную наклонную черту и четыре цифры после u. Например:
```java
char myChar = '\u0054';
```
Хотя тип char используется для хранения Unicode-символов, его можно использовать как целочисленный тип, используя сложение или вычитание.
```java
char ch1;
ch1 = 'x';
mInfoTextView.append("ch1 содержит " + ch1);
ch1++; // увеличим на единицу
mInfoTextView.append("ch1 содержит " + ch1);
```
В результате получим:
```java
ch1 содержит x
ch1 содержит y
```
Если вы думаете, что увеличив значение переменной ch1 ещё на одну единицу, получите символ "й", то глубоко заблуждаетесь. Чтобы узнать, какой символ содержится в значении переменной, заданной как int, можно воспользоваться двумя специальными методами из класса EncodingUtils.
Для стандартных символов ASCII:
```java
int i = 67;
byte[] data = { (byte) i };
CharSequence strSymbol = EncodingUtils.getAsciiString(data);
mInfoTextView.setText(strSymbol);
```
Для расширенной таблицы символов:
```java
int i = 379;
byte[] data = { (byte) i };
CharSequence strSymbol = EncodingUtils.getString(data, "windows-1251");
mInfoTextView.setText(strSymbol);
```
Методы работают со строками, но если мы используем строку из одного символа, то получим то, что нам нужно.
## Класс Character

Класс Character является оболочкой вокруг типа char. Чтобы получить значение типа char, содержащее в объекте класса Character, вызовите метод charValue(). Класс содержит огромное количество констант и методов. Например, можно определить, является ли символ цифрой или буквой, или написан ли символ в нижнем или в верхнем регистре.
## Булевы значения

Тип boolean предназначен для хранения логических значений и может принимать только одно из двух возможных значений: true или false. Данный тип всегда возвращается при использовании операторов сравнения (больше, меньше, равно, больше или равно, меньше или равно, не равно). Также он используется в управляющих операторах if и for.
```java
boolean check;
check = true;
```
В операторах if используется укороченная запись при значении true:
```java
if (check == true) ... // необязательный вариант
if (check) ... // укороченная запись
```
Java сам поймёт, что переменную check нужно сравнить с true.
## Класс Boolean

Класс Boolean является оболочкой вокруг значений типа boolean. Чтобы получить значение типа boolean из объекта класса Boolean, используйте метод booleanValue(). Тип boolean использует 4 байт памяти, а Boolean - 16.
## Приведение типов

Когда мы производим какие-то действия с переменными, то нужно следить за типами. Нельзя умножать котов на футбольные мячи, это противоречит здравому смыслу. Также и с переменными. Если вы присваиваете переменной одного типа значение другого типа, то вспоминайте теорию. Например, вы без проблем можете присвоить значение типа int переменной типа long, так как все числа из диапазона типа int гарантировано помещаются в диапазон чисел long. В этом случае Java выполнит преобразование автоматически, вы даже ничего не заметите.
Представим обратную картину - мы хотим присвоить переменной типа byte значение типа double. Java не сможет автоматически выполнить ваше желание. Не все числа типа double могут стать числом типа byte. Но часть чисел может, например, число 9. В таком случае используется так называемое приведение типов, чтобы подсказать Java о допустимости операции.
Итак, автоматическое преобразование типов осуществляется, если оба типа совместимы и длина целевого типа больше длины исходного типа. В этом случае происходит преобразование с расширением. Вы всегда можете преобразовать любое число типа byte в число типа int. Такая операция произойдёт без вашего участия автоматически. Таблица выглядит следующим образом.

![](https://github.com/maks-1987/JavaNotes/blob/master/resources/cast.png?raw=true)
Сплошные линии обозначают преобразования, выполняемые без потери данных. Штриховые линии говорят о том, что при преобразовании может произойти потеря точности. Типы целых чисел и чисел с плавающей точкой совместимы частично. Например, число 5 вполне может быть числом с плавающей точкой (5.0). Совсем не совместимы, например, char и boolean.
С автоматическим приведением мы разобрались. Рассмотрим вариант, когда нужно преобразовать число типа int в число типа byte. Преобразование автоматически невозможно, поскольку byte меньше int. Но, например, число 99 вполне можно использовать и как int и как byte. В этом случае используется явное приведение типов, то есть преобразование из одного типа в другой (преобразование с сужением). Выглядит это следующим образом:
```java
int a;
byte b;
// какие-то операции с переменной 
b = (byte) a;
```
Как видите, вы в скобках указываете тип, к которому нужно явно привести переменную. Существует ещё вариант приведения с усечением. Это когда число с плавающей точкой приводится к целочисленному типу. В этом случае отбрасывается дробная часть (хвост). Например, число 3.14 будет усечено до числа 3:
```java
double a = 3.14;
byte b = (byte) a;
```
Если размер целочисленной части слишком велик для целочисленного типа, то значение будет уменьшено до результата деления по модулю на диапазон целевого типа. Например, попробуйте преобразовать число 454.874 в тип byte:
```java
byte b;
double d = 454.874;
b = (byte) d;
infoTextView.append("b равно " + b);
```
Вывелся удивительный результат: b равно -58. Рассмотрим такой пример. Допустим у нас есть выражение, где промежуточное значение может выходить за пределы допустимого диапазона:
```java
byte a = 44;
byte b = 55;
byte c = 101;
int d = a * b - c;
```
При умножении переменных a * b промежуточный результат вышел за пределы диапазона допустимых значений для типов byte. Java во время вычисления промежуточных результатов автоматически повышает тип каждого операнда до int и ошибки не происходит. Это удобно, но может поставить в тупик в следующем примере:
```java
byte b = 50;
b = b * 2;
```
С виду всё правильно. Если не слишком больше число типа byte, а итоговый результат тоже не выходит за диапазон допустимых значений. Но Java не позволит вам написать подобный код. Происходит следующее. Во время вычисления выражения тип операндов был автоматически повышен до int, как об этом говорилось выше. При этом тип результата тоже был повышен до int. Получается, что результат вычисления равен типу int, а мы пытаемся его присвоить переменной b, которая у нас объявлена как byte. И это несмотря на то, что итоговый результат может быть типом byte. Как же выйти из этого положения? Следует использовать явное приведение типов:
```java
byte b = 50;
b = (byte) (b * 2);
```
Типы всех значений byte, short, char повышаются до типа int, как это было рассмотрено выше. Если один операнд имеет тип long, то тип всего выражения повышается до long. Если один операнд имеет тип float, то тип всего выражения повышается до float Если один операнд имеет тип double, то тип всего выражения повышается до double. Рассмотрим выражение:
```java
byte b = 45;
char c = 'c';
short s = 1005;
int i = 700000;
float f = 4.55f;
double d = 1.456;
double result = (f * b) + (i / c) - (d * s);
mInfoTextView.append("d равно " + d);
```
В первом промежуточном выражении (f * b) тип переменной b повышается до float и промежуточный результат также становится float. В следующем выражении (i / c) тип у переменной c повышается до int и промежуточный результат также становится типом int. В выражении (d * s) тип переменной s повышается до double и промежуточное выражение также становится double. В результате у нас появились три промежуточные значения типов: float, int, double. При сложении float и int мы получаем float, затем при вычитании с использованием float и double тип повышается до double, который и становится окончательным типом результата выражения.
## Классы

Java - это объектно-ориентированный язык, поэтому код в программах будет состоять из объектов и классов. Java позволяет создавать классы, которые представляют объекты из реального мира. Например, можно создать класс Car (автомобиль) или Animal (животное) и задать им различные свойства. Для класса Car логично создать такие свойства как двери, колёса, лобовое стекло и т.д. Имея класс Car, можно создать новые классы Легковушки, Грузовики, Автобусы, которые будут иметь все свойства класса Car, а также свои собственные свойства. У класса Animal соответственно можно задать свойства Лапы, Хвост, а затем создать класс Cat, у которого будет ещё дополнительное свойство Усы. Иными словами, классы могут наследовать свойства от других классов. Родительский класс называется суперклассом. Внутри классов могут быть объявлены поля и методы. Для объявления класса служит ключевое слово class.
```java
public class MainActivity extends Activity {
    // код внутри класса
}
```
В Java принято начинать имена класса с большой буквы. В классе могут быть несколько переменных и методов. Переменные, определённые внутри класса (не метода), называются переменными экземпляра или полями (fields). Код пишется внутри класса. Методы и переменные внутри класса являются членами класса. 
### Объекты

Новый объект (или экземпляр) создаётся из существующего класса при помощи ключевого слова new:
```java
Cat barsik = new Cat(); // создали кота из класса Cat
```
В большинстве случаев использоватся такой способ. Приходится дважды использовать слово Cat, оно имеет разный смысл. Слева от оператора присваивания = определяется имя переменной и его тип Cat. В правой части выражения происходит выделение памяти для нового экземпляра класса Cat и инициализируется экземпляр. Оператор присваивания присваивает переменной ссылку на только что созданный объект. Имена объектов не нужно начинать с большой буквы, как у класса. Так можно различать, где класс, а где экземпляр класса. Если имя экземпляра класса состоит из нескольких слов, то используется верблюжья нотация, когда все первые буквы слов, кроме первой, пишутся с большой - superBlackCat. При объявлении примитивных типов мы указываем нужный тип в самом начале.
```javz
int catAge;
```
Поэтому код Cat barsik также определяет его тип. Он не всегда может совпадать с именем класса.
```java
Pet barsik = new Cat();
```
В этом примере используется тип класса домашних любимцев Pet, а обращаемся к классу котов Cat. Теперь подробнее. Простой пример создания класса Box (коробка для кота):
```java
class Box {
    int width; // ширина коробки
    int height; // высота коробки
    int depth; // глубина коробки
}
```
При таком варианте Java автоматически присвоит переменным значения по умолчанию. Например, для int это будет значение 0. Но не всегда значения по умолчанию подойдут в вашем классе. Если вы создали переменную для описания количества лап у кота, то логично сразу присвоить значение 4. Поэтому считается хорошей практикой сразу присваивать нужные значения полям класса, не полагаясь на систему. Вам нужно создать отдельный файл Box.java, в который следует вставить код, описанный выше. 
Сам класс - это просто шаблон, заготовка. Чтобы ваше приложение могло использовать данный шаблон, нужно создать на его основе объект при помощи ключевого слова new:
```java
Box catBox = new Box; // создали реальный объект с именем catBox на основе шаблона Box
```
Объект catBox, объявленный в коде вашей программы, сразу займёт часть памяти на устройстве. При этом объект будет содержать собственные копии переменных экземпляра width, height, depth. Для доступа к этим переменным используется точка (.). Если мы хотим присвоить значение переменной width, то после создания объекта класса можете написать код:
```java
catBox.width = 400; // ширина коробки для кота 400 миллиметров
```
Если мы хотим вычислить объём коробки, то нужно перемножить все значения размеров коробки:
```java
Box catBox = new Box();
catBox.width = 400;
catBox.height = 200;
catBox.depth = 250;
int volume = catBox.width * catBox.height * catBox.depth;
mInfoTextView.setText("Объём коробки: " + volume);
```
Каждый объект содержит собственные копии переменных экземпляра. Можно создать несколько объектов на основе класса Box и присваивать разные значения для размеров коробки. При этом изменения переменных экземпляра одного объекта никак не влияют на переменные экземпляра другого объекта. Oбъявим два объекта класса Box:
```java
Box bigBox = new Box(); // большая коробка
Box smallBox = new Box(); // маленькая коробка
int volume;
// присвоим значения переменным для большой коробки
bigBox.width = 400;
bigBox.height = 200;
bigBox.depth = 250;
// присвоим значения переменным для маленькой коробки
smallBox.width = 200;
smallBox.height = 100;
smallBox.depth = 150;
// вычисляем объём первой коробки
volume = bigBox.width * bigBox.height * bigBox.depth;
mInfoTextView.setText("Объём большой коробки: " + volume + "\n");
// вычисляем объём маленькой коробки
volume = smallBox.width * smallBox.height * smallBox.depth;
mInfoTextView.append("Объём маленькой коробки: " + volume);
```
Когда мы используем конструкцию типа Box bigBox = new Box();, то в одной строке выполняем сразу два действия - объявляем переменную типа класса и резервируем память под объект. Можно разбить конструкцию на отдельные части:
```java
Box bigBox; // объявляем ссылку на объект
bigBox = new Box(); // резервируем память для объекта Box
```
Обычно такую конструкцию из двух строк кода не используют на практике, если нет особых причин. Когда мы используем ключевое слово new и указываем имя класса, то после имени ставим круглые скобки, которые указывают на конструктор класса.
### Ключевое слово final

Поле может быть объявлено как final (финальное). Это позволяет предотвратить изменение содержимого переменной, по сути, это становится константой. Финальное поле должно быть инициализировано во время его первого объявления.
```java
final int FILE_OPEN = 1;
```
Теперь можно пользоваться переменной FILE_OPEN так, как если бы она была константой, без риска изменения их значений. Принято записывать имена заглавными буквами. роме полей, final можно использовать для параметров метода (препятствует изменению в пределах метода) и у локальных переменных (препятствует присвоению ей значения более одного раза). Также слово final можно применять к методам, чтобы предотвратить его переопределение.
```java
class Cat {
    final void meow() {
        System.out.println("Мяу");
    }
}
class Kittent extends Cat {
    // Этот метод создать не получится
    void meow() {
        System.out.println("Да хоть гав-гав, всё равно не заведётся");
    }
}
```
Ещё один вариант использования ключевого слова final - предотвращение наследования класса. При этом неявно всего методы класса также становятся финальными. Поэтому нельзя одновременно объявить класс абстрактным и финальным, поскольку абстрактный класс является лишь шаблоном и только его подклассы реализуют методы.
```java
final class Tail {
    // ...
}
// Следующий класс недопустим
class BigTail extends Tail {
    // Ошибка! Класс Хвост нельзя переопределять.
}
```
### Ключевое слово instanceof - Проверка принадлежности к классу
Иногда требуется проверить, к какому классу принадлежит объект. Это можно сделать при помощи ключевого слова instanceof. Это булев оператор, и выражение foo instanceof Foo истинно, если объект foo принадлежит классу Foo или его наследнику, или реализует интерфейс Foo (или, в общем виде, наследует класс, который реализует интерфейс, который наследует Foo). Возьмём пример с рыбками, которые знакомы котам не понаслышке. Пусть у нас есть родительский класс Fish и у него есть унаследованные подклассы SaltwaterFish и FreshwaterFish. Мы можем протестировать, относится ли заданный объект к классу или подклассу по имени
```java
SaltwaterFish nemo = new SaltwaterFish();
if(nemo instanceof Fish) {
    // рыбка Немо относится к классу Fish
    // это может быть класс Fish (родительский класс) или подкласс типа
    // SaltwaterFish или FreshwaterFish. 
    if(nemo instanceof SaltwaterFish) {
        // Немо  - это морская рыбка!
    }
}
```
Данная проверка удобна во многих случаях. Например много классов, которые происходят от класса View - TextView, CheckBox, Button, имеющие свои собственные наборы свойств. И если имеется метод с параметром View, то при помощи instanceof можно разделить логику кода:
```java
void checkforTextView(View view)
{
     if(view instanceof TextView)
    {
        // Код для элемента TextView
    } else {
        // Для других элементов View
    }
}
```
### import - Импорт класса
Оператор import сообщает компилятору Java, где найти классы, на которые ссылается код. Любой сложный объект использует другие объекты для выполнения тех или иных функций, и оператор импорта позволяет сообщить о них компилятору Java. Оператор импорта обычно выглядит так:
```java
import ClassNameToImport;
```
За ключевым словом import следуют класс, который нужно импортировать, и точка с запятой. Имя класса должно быть полным, то есть включать свой пакет. Чтобы импортировать все классы из пакета, после имени пакета можно поместить .* 
Если мена классов совпадают, то IDE может запросить помощь. Тогда вам нужно вручную указать нужное полное имя класса. Импорт позволяет избежать долгого набора имени класса. Без импорта нам пришлось бы писать все классы в коде программы полностью.
```java
ru.alexanderklimov.MyClass.Cat.sayMeow();
java.lang.System.out.println("Мяу");
```
### Статический импорт
Существует ещё статический импорт, применяемый для импорта статических членов класса или интерфейса. Это позволяет сократить количество кода. Например, есть статические методы Math.pow(), Math.sqrt(). Для вычислений сложных формул с использованием математических методов, код становится перегружен. К примеру, вычислим гипотенузу.
```java
hypot = Math.sqrt(Math.pow(side1, 2) + Math.pow(side2, 2));
```
В данном случае без указания класса не обойтись, так как методы статические. Чтобы не набирать имена классов, их можно импортировать следующим образом:
```java
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
...
hypot = sqrt(pow(side1, 2) + pow(side2, 2));
```
После импорта уже нет необходимости указывать имя класса. Второй допустимый вариант, позволяющий сделать видимыми все статические методы класса:
```java
import static java.lang.Math.*;
```
В этом случае вам не нужно импортировать отдельные методы. Но такой подход в Android не рекомендуется, так как требует больше памяти.

### Программно получить имя класса

Иногда из программы нужно получить имя используемого класса. Для этого есть специальные методы getClass().getName() и другие родственные методы. Допустим, нам нужно узнать имя класса кнопки, на которую мы нажимаем в программе.
```java
public void onClick(View view) {
    String className = view.getClass().getName();
    String simpleName = view.getClass().getSimpleName();
    String canonicalName = view.getClass().getCanonicalName();

    if (canonicalName == null) {
        canonicalName = "null";
    }
    String s = "Имя класса: " + className + "\n" + "SimpleName: " + simpleName
            + "\n" + "CanonicalName: " + canonicalName + "\n";
    mInfoTextView.setText(s);
}
```
Получим варианты:
```
Имя класса: android.support.v7.widget.AppCompatButton
SimpleName: AppCompatButton
CanonicalName: android.support.v7.widget.AppCompatButton
```
`getSimpleName()` возвращает только имя класса без пакета, другие методы вернут полное название. Если нужно узнать имя класса активности, то достаточно кода:
```java
// подставьте имя вашей активности
String className = MainActivity.class.getName();
```
Если вам известно имя класса, то можете получить сам класс:
```java
try {
    // получим объект Class
	Class<?> myClass = Class.forName("ru.alexanderklimov.test.MainActivity");
	mInfoTextView.setText(myClass.getName()); // выводим в TextView
    
    Intent intent = new Intent(this, myClass);
    startActivity(intent);
} catch (ClassNotFoundException e) {
	// TODO Auto-generated catch block
	e.printStackTrace();
}
```
Метод `getSuperclass()` возвращает имя суперкласса. Остальные несколько десятков методов не столь популярны.
