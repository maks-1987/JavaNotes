# 6. Пакет `java.util`: инфраструктура Collections Framework
Поскольку пакет java.util содержит широкий диапазон функциональных возможностей, он достаточно объемный. Ниже приведен список основных его классов:
![](https://github.com/maks-1987/JavaNotes/blob/master/resources/CollectClass.png)

В пакете `java.util` определены следующие интерфейсы:
![](https://github.com/maks-1987/JavaNotes/blob/master/resources/CollectInterface.png)

  Инфраструктура коллекций Java Collections Framework стандартизирует способы 
управления группами объектов для программ. Инфраструктура коллекций была разработана для достижения нескольких целей:
- она должна была обеспечить высокую производительность. Реализация основных коллекций (динамических массивов, связных списков, еревьев и хеш-таблиц) отличается высокой эффективностью;
- эта система должна была позволить разным типам коллекций работать в единой манере и с высокой степенью взаимодействия;
- в-третьих, расширение и/или адаптация коллекций должны были быть просты;
- вся инфраструктура коллекций построена на едином наборе стандартных интерфейсов. Некоторые стандартные реализации (такие, как классы LinkedList, HashSetnTreeSet) этих интерфейсов можено использовать “как есть”. Также можно реализовать свои собственные коллекции. Для удобства предусмотрены различные реализации специального назначения, а также частичные реализации, которые 
облегчают создание собственных коллекций;
- в систему коллекций были добавлены механизмы интеграции стандартных массивов.

`Алгоритмы` — это другая важная часть инфраструктуры коллекций. Алгоритмы оперируют коллекциями и определены как статические  методы  класса Collections. Таким образом, они доступны всем коллекциям. Каждый класс коллекции не нуждается в реализации собственной версии. Другая сущность, тесно связанная с системой коллекций, — это интерфейс итератора `Iterator`. Итератор (iterator) предоставляет общий, стандартизированный способ доступа к элементам коллекций по одному. То есть итератор предлагает способ перебора содержимого коллекций. Поскольку каждая коллекция предоставляет итератор, элементы любого класса коллекций могут быть доступны через методы, определенные в интерфейсе Iterator. Таким образом, код, перебирающий в цикле набор (set), с минимальными изменениями можно применить, например, к списку (list).
В дополнение к коллекциям в инфраструктуре определено также несколько интерфейсов и классов карт. `Карта (mар)` хранит пары “ключ-значение”. Коллекции просто предлагают лучший способ выполнения некоторых задач.
Добавление обобщенных определений — существенное изменение в инфраструктуре коллекций, поскольку для этого она полностью была  перепроектирована. Все коллекции теперь обобщенные, и многие методы, оперирующие коллекциями, также принимают обобщенные параметры.
Сохранение элементарных типов в коллекциях облегчает автоматическая упаковка. Коллекции могут сохранять только ссылки, но не элементарные значения. 
Все классы коллекций модифицированы таким образом, что реализуют интерфейс Iterable. Это значит, что можно перебрать содержимое  коллекции, используя стиль “for-each” цикла for. Раньше для перебора коллекции необходимо было использовать итератор, программно 
конструируя цикл. Хотя итераторы все еще применяются для некоторых целей, во многих случаях циклы на основе итераторов могут быть заменены циклами for. 
### Интерфейсы коллекций
<p>Инфраструктура коллекций определяет несколько интерфейсов. <br>
  <table>
    <tr>
      <td>Интерфейс</td>
      <td align="center">Описание</td>
    </tr>
    <tr>
      <td>Collection</td>
      <td>Позволяет работать с группами объектов. Это — вершина иерархии коллекций</td>
    </tr>
    <tr>
      <td>Deque</td>
      <td>Расширяет интерфейс Queue для обработки двунаправленных очередей</td>
    </tr>
    <tr>
      <td>List</td>
      <td>Расширяет интерфейс Collection для управления последовательностями (списками объектов)</td>
    </tr>
    <tr>
      <td>NavigableSet</td>
      <td>Расширяет интерфейс SortedSet для обработки извлечения элементов на основе поисков по ближайшему соответствию</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>Расширяет интерфейс Collection для управления специальными типами списков, в которых элементы удаляются только с начала</td>
    </tr>
    <tr>
      <td>Set</td>
      <td>Расширяет интерфейс Collection для управления наборами, которые должны содержать уникальные элементы</td>
    </tr>
    <tr>
      <td>SortedSet</td>
      <td>Расширяет интерфейс Set для управления сортированными наборами</td>
    </tr>
  </table>
</p>
В дополнение к этим интерфейсам, коллекции также используют интерфейсы <ins>Comparator, RandomAccess, Iterator и Listlterator.</ins> 
Интерфейс Comparator определяет два сравниваемых объекта; интерфейсы Iterator и Listlterator перечисляют объекты в коллекции. Реализуя интерфейс RandomAccess, список поддерживает эффективный произвольный доступ к своим элементам. </br>
Чтобы обеспечить максимальную гибкость в применении, интерфейсы коллекций позволяют некоторым методам быть необязательными.  Необязательные методы позволяют модифицировать содержимое коллекций. Коллекции, которые поддерживают эти методы, называются модифицируемыми. Коллекции, которые не позволяют изменять собственное содержимое, называются пемодифицируемыми. Если предпринимается попытка вызвать один из этих методов для немодифицируемой коллекции, передается исключение <b>UnsupportedOperationException</b>. Все встроенные коллекции модифицируемы.

### Интерфейс Collection
Этот интерфейс является фундаментом, на котором построена вся инфраструктура коллекций, поскольку он должен быть реализован всеми классами коллекций. Интерфейс Collection — это обобщенный интерфейс, имеющий следующее объявление. `interface Collection<E>`. Здесь `Е` указывает тип объектов, которые будет содержать коллекция. Интерфейс Collection расширяет  интерфейс  Iterable. Это значит, что все коллекции можно перебирать циклами вида “for-each”.</br> Интерфейс Collection определяет основные методы, которые будут иметь все коллекции.

Метод | Описание
--- | ---
`boolean add(E объект)` | Добавляет объект к вызывающей коллекции. Возвращает значение true, если объект был добавлен к коллекции
`boolean addAll(Collection<? extends E> c)` | Добавляет все элементы с к вызывающей коллекции. Возвращает значение true, если коллекция изменена (т.е. все элементы добавлены). В противном случае возвращает значение false
`void clear()` | Удаляет все элементы вызывающей коллекции
`boolean contains(Object объект)` | Возвращает значение true, если объект является элементом вызывающей коллекции. В противном случае возвращает значение false
`boolean containsAll(Collection<?> c)` | Возвращает значение true, если вызывающая коллекция содержит все элементы с. В противном случае возвращает значение false
`boolean equals(Object объект)` | Возвращает значение true, если вызывающая коллекция и объект эквивалентны. В противном случае возвращает значение false
`int hashCode()` | Возвращает хеш-код вызывающей коллекции
`boolean isEmpty()` | Возвращает значение true, если вызывающая коллекция пуста. В противном случае возвращает значение false
`Iterator<E> iterator()` | Возвращает итератор для вызывающей коллекции
`boolean remove(Object объект)` | Удаляет один экземпляр объект из вызывающей коллекции. Возвращает значение true, если элемент удален. 
`boolean removeAll(Collection<?> c)` | Удаляет все элементы с из вызывающей коллекции. Возвращает значение true, если в результате коллекция изменяется (т.е. элементы удалены). В противном случае возвращает значение false
`boolean retainAll(Collection<?> c)` | Удаляет все элементы, кроме входящих в с из вызывающей коллекции. Возвращает значение true, если в результате коллекция изменяется (т.е. элементы удалены). В противном случае возвращает значение false
`int size()` | Возвращает количество элементов, содержащихся в коллекции
`Object[] toArray()` | Возвращает массив, содержащий все элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции
`<T> T[] toArray(T array[])` | Возвращает массив, содержащий элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции. Если размер массива array равен количеству элементов, он возвращается. Если размер массива array меньше количества элементов, создается и возвращается новый массив нужного размера. Если размер массива array больше количества элементов, то элементы, следующие за последним из коллекции, устанавливаются равными null. Если любой элемент коллекции имеет тип, не являющийся подтипом массива array, передается исключение ArrayStoreException
  
  ### Интерфейс List
Этот интерфейс расширяет интерфейс Collection и определяет такое поведение коллекций, которое сохраняет последовательность элементов. Элементы могут быть вставлены или извлечены по их позиции в списке с помощью индекса, начинающегося с нуля. Список может содержать повторяющиеся элементы. Интерфейс List — это обобщенный интерфейс, объявленный следующим образом. `interface List<Ј>`. Здесь `Е` указывает тип объектов, которые должен содержать список.

Метод | Описание
---|---
`void add(int индекс, Е объект)` | Вставляет объект в позицию вызывающего списка, указанную в параметре индекс. Любые ранее вставленные элементы за указанной позицией вставки смещаются вверх. То есть никакие элементы не перезаписываются 
`boolean addAll(int индекс, Collection<? extends Е> с)` | Вставляет все элементы с в вызывающий список, начиная с позиции, переданной в индекс. Все ранее существовавшие элементы за точкой вставки смещаются вверх. То есть никакие элементы не перезаписываются. Возвращает значение true, если вызывающий список изменяется, и значение fа1sе — в противном случае 
`Е get(int индекс)` | Возвращает объект, сохраненный в указанной позиции вызывающего списка
`int indexOf(Object объект)` | Возвращает индекс первого экземпляра объект в вызывающем списке. Если объект не содержится в списке, возвращается значение -1 
`int lastlndexOf(Object объект)` | Возвращает индекс последнего экземпляра объект в вызывающем списке. Если объект не содержится в списке, возвращается значение -1
`ListIterator<E> listlterator()`| Возвращает итератор, указывающий на начало списк
`ListIterator<E> listlterator(int индекс)`| Возвращает итератор, указывающий на заданную позицию в списке
`E remove(int индекс)`| Удаляет элемент из вызывающего списка в позиции индекс и возвращает удаленный элемент. Результирующий список уплотняется, т.е. элементы, следующие за удаленным, сдвигаются на одну позицию назад
`E set(int индекс, E объект)`| Присваивает объект элементу, находящемуся в списке в позиции индекс. Возвращает прежнее значение
`List<E> subList(int начало, int конец)`| Возвращает список, включающий элементы от *начало* до *конец-1* из вызывающего списка. Элементы из возвращаемого списка также сохраняют ссылки в вызывающем списке

### Интерфейс Set
Интерфейс Set определяет набор. Он расширяет интерфейс Collection и определяет поведение коллекций, не допускающих дублирования элементов. Таким образом, метод `add()` возвращает значение *false* при попытке добавить в набор дублированный элемент. Он не определяет никаких собственных дополнительных методов. Интерфейс Set — это обобщенный интерфейс, который объявлен следующим образом. `interface Set<E>`. Здесь `Е` указывает тип объектов, которые должен содержать набор.
### Интерфейс SortedSet
Интерфейс SortedSet расширяет интерфейс Set и объявляет поведение наборов, отсортированных в порядке возрастания. 

Метод |Описание
---|---
`Comparator<? super S> comparator()` | Возвращает компаратор отсортированного набора. Если для набора применяется естественный порядок сортировки, возвращается значение null
`Е first()` |Возвращается первый элемент вызывающего отсортированного набора
`SortedSet<E> headset(Е конец)` | Возвращается объект интерфейса SortedSet, содержащий элементы из вызывающего набора, которые предшествуют *конец*. Элементы из возвращенного набора имеют также ссылки в вызывающем объекте
`Е last()` |  Возвращается последний элемент вызывающего отсортированного набора
`SortedSet<E> subset(Е начало, Е конец)` | Возвращается объект интерфейса SortedSet, который включает элементы, находящиеся между *начало* и *конец-1*. Элементы из возвращенного набора имеют также ссылки в вызывающем объекте
`SortedSet<E> tailSet(E начало)`| Возвращается объект интерфейса SortedSet, содержащий элементы из вызывающего набора, которые следуют за *конец*. Элементы из возвращенного набора имеют также ссылки в вызывающем объекте

### Интерфейс NavigableSet
Этот интерфейс расширяет интерфейс SortedSet и объявляет поведение кол­
лекции, которая поддерживает извлечение элементов на основе ближайшего со­
ответствия заданному значению или значениям.

Метод| Описание
---|--- 
`Е ceiling(Е объект)` | Ищет в наборе наименьший элемент `е`, для которого истинно е>-объект. Если такой элемент найден, он возвращается. В противном случае возвращается значение null
`Iterator<E> descendinglterator()` | Возвращает итератор, перемещающийся от большего к меньшему, другими словами, обратный итератор
`NavigableSet<E> descendingSet()` | Возвращает объект интерфейса NavigableSet, представляющий собой обратную версию вызывающего набора. Результирующий набор поддерживается вызывающим набором
`E floor(E объект)` | Ищет в наборе наибольший элемент `е`, для которого истинно `е<=объект`. Если такой элемент найден, он возвращается. В противном случае возвращается значение null
`NavigableSet<E> headSet (Е верхнГраница, boolean включать)` | Возвращает объект интерфейса NavigableSet, включающий все элементы вызывающего набора, меньшие верхнГраница. Результирующий набор поддерживается вызывающим набором
`Е higher(Е объект)` | Ищет в наборе наибольший элемент `е`, для которого истинно `е>объект`. Если такой элемент найден, он возвращается. В противном случае возвращается значение null
`Е lower(Е объект)` | Ищет в наборе наименьший элемент `е`, для которого истинно `е<объект`. Если такой элемент найден, он возвращается. В противном случае возвращается значение null
`Е pollFirst()` | Возвращает первый элемент, удаляя его в процессе. Поскольку набор отсортирован, это будет элемент с наименьшим значением. Возвращает значение null в случае пустого набора
`Е pollLast()` | Возвращает последний элемент, удаляя его в процессе. Поскольку набор отсортирован, это будет элемент с наибольшим значением. Возвращает значение null в случае пустого набора
`NavigableSet<E> subset(Е нижнГраница, boolean включатьНижн, Е верхнГраница, boolean включатьВерхн)` | Возвращает объект интерфейса NavigableSet, включающий все элементы вызывающего набора, которые больше *нижнГраница* и меньше *верхнГраница*. Если параметр включатьНижн содержит значение true, то элемент, равный *нижнГраница*, включается. Если параметр *включатьВерхн* содержит значение true, также включается элемент, равный *верхнГраница*
`NavigableSet<E> tailSet(Е нижнГраница, boolean включать)` |Возвращает объект интерфейса NavigableSet, включающий все элементы из вызывающего набора, которые больше *нижнГраница*. Если параметр включать содержит значение true, в результат включается элемент, равный *нижнГраница*. Результирующий набор поддерживается вызывающим набором

### Интерфейс Queue
Этот интерфейс расширяет интерфейс Collection и объявляет поведение очередей, которые представляют собой список по принципу “первый вошел — первый вышел”. Однако существуют разные типы очередей, в которых порядок основан на некотором критерии. Несмотря на свою простоту, интерфейс Queue представляет интерес с нескольких точек зрения. *Во-первых*, элементы могут удаляться только из начала очереди. *Во-вторых*, есть два метода, которыми можно получать и удалять элементы, — `poll()` и `remove()`. 

Метод | Описание
---|---
`Е element()` | Возвращает элемент из головы очереди. Элемент не удаляется. Если очередь пуста, передается исключение `NoSuchElementException`
`boolean offer(Е объект)` |Пытается добавить объект в очередь. Возвращает значение true, если объект добавлен, и значение false — в противном случае
`Е реек()`|Возвращает элемент из головы очереди. Возвращает значение null, если очередь пуста. Элемент не удаляется
`Е poll()` |Возвращает элемент из головы очереди и удаляет его. Возвращает значение null, если очередь пуста
`Е remove()`|Удаляет элемент из головы очереди, возвращая его. Инициирует исключение `NoSuchElementException`, если очередь пуста

### Интерфейс Dequeue
Интерфейс Dequeue расширяет интерфейс Queue и описывает поведение двунаправленной очереди, которая может функционировать как стандартная очередь “первый вошел — первый вышел” либо как стек “последний вошел — первый вышел”. Интерфейс Dequeue — это обобщенный интерфейс со следующим объявлением. `interface Deque<E>`. Здесь `Е` определяет тип объектов, которые будет содержать двусторонняя очередь. 

Метод |Описание
---|---
`void addFirst(E объект)` |Добавляет объект в голову двунаправленной очереди. Передает исключение `IllegalStateException`, если в очереди фиксированной длины нет места
`void addLast(E объект)` |Добавляет объект в хвост двунаправленной очереди. Передает исключение `IllegalStateException`, если в очереди фиксированной длины нет места
`Iterator<E> descendinglterator()` |Возвращает итератор, перемещающийся от хвоста к голове двунаправленной очереди. То есть возвращает обратный итератор
`E getFirst()` |Возвращает первый элемент двунаправленной очереди. Объект из очереди не удаляется. В случае пустой двунаправленной очереди передает исключение `NoSuchElementException`
`E getLast()` |Возвращает последний элемент двунаправленной очереди. Объект из очереди не удаляется. В случае пустой двунаправленной очереди передает исключение `NoSuchElementException`
`booleanofferFirst(E объект)` |Пытается добавить объект в голову двунаправленной очереди. Возвращает значение true, если объект добавлен, и значение false — в противном случае. Таким образом, этот метод возвращает значение false при попытке добавить объект в полную двунаправленную очередь фиксированной длины
`booleanofferLast(E объект)` |Пытается добавить объект в хвост двунаправленной очереди. Возвращает значение true, если объект добавлен, и значение fа1sе — в противном случае
`Z peekFirst()` |Возвращает элемент, находящийся в голове двунаправленной очереди. Возвращает значение null, если очередь пуста. Объект из очереди не удаляется
`E peekLast()` |Возвращает элемент, находящийся в хвосте двунаправленной очереди. Возвращает значение null, если очередь пуста. Объект из очереди не удаляется
`E pollFirst()` |Возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Возвращает значение null, если очередь пуста
`E pollLast()` |Возвращает элемент, находящийся в хвосте двунаправленной очереди, одновременно удаляя его из очереди. Возвращает значение nul1, если очередь пуста
`E pop()` |Возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Передает исключение ёNoSuchElementExceptionё, если очередь пуста
`void push(E объект)` |Добавляет элемент в голову двунаправленной очереди. Если в очереди фиксированной длины нет места, передает исключение`IllegalStateException`
`E removeFirst()` |Возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Передает исключение `NoSuchElementException`, если очередь пуста

Интерфейс Deque включает методы `push()` и `pop()`, которые позволяют интерфейсу Deque функционировать в качестве стека. 
Кроме того, следует обратить внимание на метод `descendinglterator()`. Он возвращает итератор, который возвращает элементы в обратном порядке. Другими cловами, итератор, перемещающийся от конца коллекции к ее началу. Реализация интерфейса Deque может быть ограниченной по емкости, т.е. в него может быть добавлено ограниченное количество  элементов. 

## Классы коллекций

Базовые классы коллекций
[](https://github.com/maks-1987/JavaNotes/blob/master/resources/%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B%D0%9A%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA.PNG)















