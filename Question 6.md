# 6. Пакет `java.util`: инфраструктура Collections Framework
Поскольку пакет java.util содержит широкий диапазон функциональных возможностей, он достаточно объемный. Ниже приведен список основных его классов:
![](https://github.com/maks-1987/JavaNotes/blob/master/resources/CollectClass.png)

В пакете `java.util` определены следующие интерфейсы:
![](https://github.com/maks-1987/JavaNotes/blob/master/resources/CollectInterface.png)

  Инфраструктура коллекций Java Collections Framework стандартизирует способы 
управления группами объектов для программ. Инфраструктура коллекций была разработана для достижения нескольких целей:
- она должна была обеспечить высокую производительность. Реализация основных коллекций (динамических массивов, связных списков, еревьев и хеш-таблиц) отличается высокой эффективностью;
- эта система должна была позволить разным типам коллекций работать в единой манере и с высокой степенью взаимодействия;
- в-третьих, расширение и/или адаптация коллекций должны были быть просты;
- вся инфраструктура коллекций построена на едином наборе стандартных интерфейсов. Некоторые стандартные реализации (такие, как классы LinkedList, HashSetnTreeSet) этих интерфейсов можено использовать “как есть”. Также можно реализовать свои собственные коллекции. Для удобства предусмотрены различные реализации специального назначения, а также частичные реализации, которые 
облегчают создание собственных коллекций;
- в систему коллекций были добавлены механизмы интеграции стандартных массивов.

<p>`Алгоритмы` — это другая важная часть инфраструктуры коллекций. Алгоритмы оперируют коллекциями и определены как статические  методы  класса Collections. Таким образом, они доступны всем коллекциям. Каждый класс коллекции не нуждается в реализации собственной версии. Другая сущность, тесно связанная с системой коллекций, — это интерфейс итератора `Iterator`. Итератор (iterator) предоставляет общий, стандартизированный способ доступа к элементам коллекций по одному. То есть итератор предлагает способ перебора содержимого коллекций. Поскольку каждая коллекция предоставляет итератор, элементы любого класса коллекций могут быть доступны через методы, определенные в интерфейсе Iterator. Таким образом, код, перебирающий в цикле набор (set), с минимальными изменениями можно применить, например, к списку (list).
В дополнение к коллекциям в инфраструктуре определено также несколько интерфейсов и классов карт. `Карта (mар)` хранит пары “ключ-значение”. Коллекции просто предлагают лучший способ выполнения некоторых задач.
Добавление обобщенных определений — существенное изменение в инфраструктуре коллекций, поскольку для этого она полностью была  перепроектирована. Все коллекции теперь обобщенные, и многие методы, оперирующие коллекциями, также принимают обобщенные параметры.
Сохранение элементарных типов в коллекциях облегчает автоматическая упаковка. Коллекции могут сохранять только ссылки, но не элементарные значения.
</p> 
Все классы коллекций модифицированы таким образом, что реализуют интерфейс Iterable. Это значит, что можно перебрать содержимое  коллекции, используя стиль “for-each” цикла for. Раньше для перебора коллекции необходимо было использовать итератор, программно 
конструируя цикл. Хотя итераторы все еще применяются для некоторых целей, во многих случаях циклы на основе итераторов могут быть заменены циклами for. 
<b>Интерфейсы коллекций</b>
<p>Инфраструктура коллекций определяет несколько интерфейсов. <br>
  <table>
    <tr>
      <td>Интерфейс</td>
      <td align="center">Описание</td>
    </tr>
    <tr>
      <td>Collection</td>
      <td>Позволяет работать с группами объектов. Это — вершина иерархии коллекций</td>
    </tr>
    <tr>
      <td>Deque</td>
      <td>Расширяет интерфейс Queue для обработки двунаправленных очередей</td>
    </tr>
    <tr>
      <td>List</td>
      <td>Расширяет интерфейс Collection для управления последовательностями (списками объектов)</td>
    </tr>
    <tr>
      <td>NavigableSet</td>
      <td>Расширяет интерфейс SortedSet для обработки извлечения элементов на основе поисков по ближайшему соответствию</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>Расширяет интерфейс Collection для управления специальными типами списков, в которых элементы удаляются только с начала</td>
    </tr>
    <tr>
      <td>Set</td>
      <td>Расширяет интерфейс Collection для управления наборами, которые должны содержать уникальные элементы</td>
    </tr>
    <tr>
      <td>SortedSet</td>
      <td>Расширяет интерфейс Set для управления сортированными наборами</td>
    </tr>
  </table>
</p>
В дополнение к этим интерфейсам, коллекции также используют интерфейсы <ins>Comparator, RandomAccess, Iterator и Listlterator.</ins> 
Интерфейс Comparator определяет два сравниваемых объекта; интерфейсы Iterator и Listlterator перечисляют объекты в коллекции. Реализуя интерфейс RandomAccess, список поддерживает эффективный произвольный доступ к своим элементам. </br>
Чтобы обеспечить максимальную гибкость в применении, интерфейсы коллекций позволяют некоторым методам быть необязательными.  Необязательные методы позволяют модифицировать содержимое коллекций. Коллекции, которые поддерживают эти методы, называются модифицируемыми. Коллекции, которые не позволяют изменять собственное содержимое, называются пемодифицируемыми. Если предпринимается попытка вызвать один из этих методов для немодифицируемой коллекции, передается исключение <b>UnsupportedOperationException</b>. Все встроенные коллекции модифицируемы.
### Интерфейс Collection
Этот интерфейс является фундаментом, на котором построена вся инфраструктура коллекций, поскольку он должен быть реализован всеми классами коллекций. Интерфейс Collection — это обобщенный интерфейс, имеющий следующее объявление. `interface Collection<E>`. Здесь `Е` указывает тип объектов, которые будет содержать коллекция. Интерфейс Collection расширяет  интерфейс  Iterable. Это значит, что все коллекции можно перебирать циклами вида “for-each”.





